using Conventional;
using Conventional.Conventions;
using StarterApp.Api.Infrastructure;

namespace StarterApp.Tests.Conventions;

/// <summary>
/// Convention tests using Best.Conventional library for enforcing architectural rules.
/// These tests ensure consistent naming conventions, proper encapsulation, and architectural
/// patterns across the entire solution. They serve as automated code quality gates that
/// prevent architectural drift and maintain consistency as the codebase grows.
/// 
/// Based on Andrew Best's Conventional library: https://github.com/andrewabest/Conventional
/// 
/// Key Benefits:
/// - Enforces consistent naming patterns across all layers
/// - Prevents violations of domain-driven design principles
/// - Ensures proper encapsulation and immutability where required
/// - Maintains clean architecture separation of concerns
/// - Provides early feedback on architectural violations during development
/// </summary>
public class ConventionTests
{
    /// <summary>
    /// Reference to the Domain assembly containing domain entities, value objects, and business logic.
    /// Used to enforce domain-specific architectural rules.
    /// </summary>
    private static readonly Assembly DomainAssembly = typeof(Product).Assembly;
    
    /// <summary>
    /// Reference to the API assembly containing controllers, DTOs, commands, queries, and application services.
    /// Used to enforce presentation and application layer architectural rules.
    /// </summary>
    private static readonly Assembly ApiAssembly = typeof(IApiMarker).Assembly;

    /// <summary>
    /// Helper method to detect compiler-generated types (like async state machines, display classes, etc.)
    /// These types should be excluded from convention checks as they are generated by the C# compiler
    /// and don't represent user-authored code that should follow our architectural conventions.
    /// 
    /// Detects:
    /// - Async state machines (generated for async/await methods)
    /// - Lambda expression closures and display classes
    /// - Anonymous types and other compiler artifacts
    /// - Nested types (often compiler-generated)
    /// </summary>
    /// <param name="type">The type to check for compiler generation</param>
    /// <returns>True if the type is compiler-generated and should be excluded from conventions</returns>
    private static bool IsCompilerGenerated(Type type)
    {
        return type.GetCustomAttributes(typeof(System.Runtime.CompilerServices.CompilerGeneratedAttribute), false).Any() ||
               type.Name.Contains("<") || 
               type.Name.Contains(">") ||
               type.Name.StartsWith("<>") ||
               type.Name.Contains("d__") ||
               type.Name.Contains("c__DisplayClass") ||
               type.Name.Contains("__StaticArrayInitTypeSize") ||
               type.IsNested; // Often compiler-generated types are nested
    }    /// <summary>
    /// Ensures all ASP.NET Core controllers follow the standard naming convention.
    /// Controllers are the entry points for HTTP requests in the presentation layer.
    /// 
    /// Architectural Rationale:
    /// - Provides consistent naming that makes the codebase self-documenting
    /// - Enables developers to quickly identify controller classes
    /// - Follows .NET and ASP.NET Core community standards
    /// - Supports tooling and scaffolding that expects this naming pattern
    /// 
    /// Example: ProductController, UserController, OrderController
    /// </summary>
    [Fact]
    public void Controllers_ShouldFollowNamingConventions()
    {
        var controllerTypes = ApiAssembly.GetTypes()
            .Where(t => typeof(ControllerBase).IsAssignableFrom(t));

        controllerTypes
            .MustConformTo(Convention.NameMustEndWith("Controller"))
            .WithFailureAssertion(Assert.Fail);
    }

    /// <summary>
    /// Ensures Data Transfer Objects (DTOs) and Read Models follow consistent naming conventions.
    /// DTOs are used to transfer data between layers and across service boundaries.
    /// 
    /// Architectural Rationale:
    /// - DTOs represent data contracts for external communication
    /// - Clear naming distinguishes them from domain entities
    /// - Supports CQRS pattern where read models are optimized for queries
    /// - Prevents confusion between domain objects and data transfer objects
    /// 
    /// Example: ProductDto, UserReadModel, OrderSummaryDto
    /// </summary>
    [Fact]
    public void DTOs_ShouldFollowNamingConventions()
    {
        var dtoTypes = ApiAssembly.GetTypes()
            .Where(t => t.Namespace != null && 
                   (t.Namespace.Contains("DTOs") || t.Namespace.Contains("ReadModels")) &&
                   t.IsClass && !t.IsAbstract);

        dtoTypes
            .MustConformTo(Convention.NameMustEndWith("Dto").Or(Convention.NameMustEndWith("ReadModel")))
            .WithFailureAssertion(Assert.Fail);
    }    /// <summary>
    /// Ensures all command objects follow consistent naming conventions.
    /// Commands represent requests to change the state of the system (write operations).
    /// 
    /// Architectural Rationale:
    /// - Commands are part of the CQRS (Command Query Responsibility Segregation) pattern
    /// - Clear naming distinguishes write operations from read operations (queries)
    /// - Enables intention-revealing design where the command name describes the business action
    /// - Supports mediator pattern and command handler pipeline processing
    /// - Excludes handlers and services as they have different responsibilities
    /// 
    /// Example: CreateProductCommand, UpdateUserCommand, DeleteOrderCommand
    /// </summary>
    [Fact]
    public void Commands_ShouldFollowNamingConventions()
    {
        var commandTypes = ApiAssembly.GetTypes()
            .Where(t => t.Namespace != null && t.Namespace.Contains("Commands") &&
                   t.IsClass && !t.IsAbstract &&
                   !t.Name.EndsWith("Handler") && !t.Name.EndsWith("Service") &&
                   !IsCompilerGenerated(t));

        commandTypes
            .MustConformTo(Convention.NameMustEndWith("Command"))
            .WithFailureAssertion(Assert.Fail);
    }

    /// <summary>
    /// Ensures all query objects follow consistent naming conventions.
    /// Queries represent requests to retrieve data from the system (read operations).
    /// 
    /// Architectural Rationale:
    /// - Queries are part of the CQRS pattern for read operations
    /// - Clear naming distinguishes read operations from write operations (commands)
    /// - Supports query optimization and caching strategies
    /// - Enables separation of read and write concerns
    /// - Excludes handlers and services as they have different responsibilities
    /// 
    /// Example: GetProductQuery, ListUsersQuery, SearchOrdersQuery
    /// </summary>
    [Fact]
    public void Queries_ShouldFollowNamingConventions()
    {
        var queryTypes = ApiAssembly.GetTypes()
            .Where(t => t.Namespace != null && t.Namespace.Contains("Queries") &&
                   t.IsClass && !t.IsAbstract &&
                   !t.Name.EndsWith("Handler") && !t.Name.EndsWith("Service") &&
                   !IsCompilerGenerated(t));

        queryTypes
            .MustConformTo(Convention.NameMustEndWith("Query"))
            .WithFailureAssertion(Assert.Fail);
    }    /// <summary>
    /// Ensures domain entities maintain proper encapsulation with private setters.
    /// Domain entities are the core business objects that contain business logic and rules.
    /// 
    /// Architectural Rationale:
    /// - Protects domain invariants by preventing external code from directly modifying entity state
    /// - Enforces that all state changes go through domain methods that can validate business rules
    /// - Supports Domain-Driven Design (DDD) principles of rich domain models
    /// - Prevents anemic domain models where entities are just data containers
    /// - Ensures that the entity's behavior controls its own state transitions
    /// 
    /// Example: Product entity with private setters that can only be modified through domain methods
    /// </summary>
    [Fact]
    public void DomainEntities_ShouldHaveProperEncapsulation()
    {
        var entityTypes = DomainAssembly.GetTypes()
            .Where(t => t.Namespace != null && t.Namespace.Contains("Entities") &&
                   t.IsClass && !t.IsAbstract);

        entityTypes
            .MustConformTo(Convention.PropertiesMustHavePrivateSetters)
            .WithFailureAssertion(Assert.Fail);
    }

    /// <summary>
    /// Ensures value objects are immutable with private setters.
    /// Value objects represent descriptive aspects of the domain with no conceptual identity.
    /// 
    /// Architectural Rationale:
    /// - Immutability prevents accidental modification and ensures thread safety
    /// - Value objects should be replaced rather than modified (immutable semantics)
    /// - Supports functional programming principles and reduces side effects
    /// - Prevents shared mutable state issues in concurrent environments
    /// - Ensures that value objects maintain their identity through their values
    /// 
    /// Example: Money, Address, PhoneNumber - once created, they cannot be modified
    /// </summary>
    [Fact]
    public void ValueObjects_ShouldBeImmutable()
    {
        var valueObjectTypes = DomainAssembly.GetTypes()
            .Where(t => t.Namespace != null && t.Namespace.Contains("ValueObjects") &&
                   t.IsClass && !t.IsAbstract);

        valueObjectTypes
            .MustConformTo(Convention.PropertiesMustHavePrivateSetters)
            .WithFailureAssertion(Assert.Fail);
    }

    /// <summary>
    /// Ensures DTOs and Read Models have public getters for data access.
    /// DTOs are designed to transfer data and should be easily serializable and accessible.
    /// 
    /// Architectural Rationale:
    /// - DTOs need public getters for serialization frameworks (JSON, XML, etc.)
    /// - Read models are optimized for data consumption and need easy access to properties
    /// - Supports data binding in UI frameworks and API serialization
    /// - Enables reflection-based operations like mapping and validation
    /// - Contrasts with domain objects that prioritize encapsulation over accessibility
    /// 
    /// Example: ProductDto with public getters for Id, Name, Price properties
    /// </summary>
    [Fact]
    public void DTOs_ShouldHavePublicGetters()
    {
        var dtoTypes = ApiAssembly.GetTypes()
            .Where(t => t.Name.EndsWith("Dto") || t.Name.EndsWith("ReadModel"));

        dtoTypes
            .MustConformTo(Convention.PropertiesMustHavePublicGetters)
            .WithFailureAssertion(Assert.Fail);
    }

    /// <summary>
    /// Ensures asynchronous methods follow the "Async" suffix naming convention.
    /// This promotes clarity about asynchronous operations throughout the codebase.
    /// 
    /// Architectural Rationale:
    /// - Follows .NET Framework Design Guidelines for async method naming
    /// - Makes asynchronous operations immediately visible to developers
    /// - Prevents confusion between synchronous and asynchronous versions of methods
    /// - Supports tooling and static analysis that relies on naming conventions
    /// - Excludes controllers (which often have async actions without Async suffix)
    /// - Excludes MediatR handlers (which follow their own naming conventions)
    /// 
    /// Example: GetProductAsync, SaveChangesAsync, ProcessOrderAsync
    /// </summary>
    [Fact]
    public void AsyncMethods_ShouldHaveAsyncSuffix()
    {
        var assemblies = new[] { ApiAssembly, DomainAssembly };
        
        foreach (var assembly in assemblies)
        {
            var types = assembly.GetTypes()
                .Where(t => t.IsClass && !t.IsAbstract &&
                       !typeof(ControllerBase).IsAssignableFrom(t) && // Exclude controllers
                       !t.Name.EndsWith("Handler") && // Exclude MediatR handlers
                       !IsCompilerGenerated(t));            types
                .MustConformTo(Convention.AsyncMethodsMustHaveAsyncSuffix)
                .WithFailureAssertion(Assert.Fail);
        }
    }

    /// <summary>
    /// Ensures application services follow consistent naming conventions.
    /// Services contain application logic and coordinate between different parts of the system.
    /// 
    /// Architectural Rationale:
    /// - Services represent application layer concerns and business workflows
    /// - Clear naming distinguishes them from domain services and infrastructure services
    /// - Supports dependency injection and service location patterns
    /// - Enables separation of concerns between controllers and business logic
    /// - Makes the service layer self-documenting and discoverable
    /// 
    /// Example: ProductService, UserService, OrderProcessingService
    /// </summary>
    [Fact]
    public void Services_ShouldFollowNamingConventions()
    {
        var serviceTypes = ApiAssembly.GetTypes()
            .Where(t => t.Namespace != null && t.Namespace.Contains("Services") &&
                   t.IsClass && !t.IsAbstract &&
                   !IsCompilerGenerated(t));        serviceTypes
            .MustConformTo(Convention.NameMustEndWith("Service"))
            .WithFailureAssertion(Assert.Fail);
    }

    /// <summary>
    /// Ensures repository classes follow consistent naming conventions.
    /// Repositories provide an abstraction over data access and storage concerns.
    /// 
    /// Architectural Rationale:
    /// - Repositories abstract data access patterns following DDD principles
    /// - Clear naming distinguishes them from other data access objects
    /// - Supports the Repository pattern for domain-driven design
    /// - Enables unit testing by providing clear abstraction boundaries
    /// - Makes data access layer intentions explicit and discoverable
    /// 
    /// Example: ProductRepository, UserRepository, OrderRepository
    /// </summary>
    [Fact]
    public void Repositories_ShouldFollowNamingConventions()
    {
        var repositoryTypes = ApiAssembly.GetTypes()
            .Where(t => t.Namespace != null && t.Namespace.Contains("Repositories") &&
                   t.IsClass && !t.IsAbstract &&
                   !IsCompilerGenerated(t));        repositoryTypes
            .MustConformTo(Convention.NameMustEndWith("Repository"))
            .WithFailureAssertion(Assert.Fail);
    }

    /// <summary>
    /// Ensures test classes follow consistent naming conventions.
    /// Test classes should be easily identifiable and follow community standards.
    /// 
    /// Architectural Rationale:
    /// - Test naming conventions improve test discoverability and organization
    /// - Follows xUnit and .NET testing community standards
    /// - Supports test runners and tooling that rely on naming patterns
    /// - Makes test purpose and scope immediately clear to developers
    /// - Enables consistent test organization across the entire solution
    /// 
    /// Example: ProductControllerTests, UserServiceTest, OrderRepositoryTests
    /// </summary>
    [Fact]
    public void TestClasses_ShouldFollowNamingConventions()
    {var testTypes = Assembly.GetExecutingAssembly().GetTypes()
            .Where(t => t.IsClass && !t.IsAbstract &&
                   t.GetMethods().Any(m => m.GetCustomAttributes(typeof(FactAttribute), false).Any()));
                   
        testTypes
            .MustConformTo(Convention.NameMustEndWith("Tests").Or(Convention.NameMustEndWith("Test")))
            .WithFailureAssertion(Assert.Fail);
    }
}
